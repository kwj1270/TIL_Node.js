01 노드 시작하기
=======================
# 1. 핵심 개념 이해하기 
```
Node.js 는 크롬 V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타입입니다.     
Node.js 는 이벤트 기반, 논블로킹 I/O 모델을 사용해 가볍고 효율적입니다.     
Node.js 의 패키지 생태계인 npm은 세계에서 가장 큰 오픈 소스 라이브러리 생태계이기도 합니다.  
```  
런타임 : 특정 언어로 만든 프로그램들을 실행할 수 있는 환경         
이벤트 기반 : 이벤트가 발생할 때 미리 지정해둔 작업을 수행하는 방식         
논블로킹 : 이전 작업이 완료될 때까지 멈추지 않고 다음 작업을 수행함을 뜻합니다.    
     
## 1.1. 자바 스크립트 런타임      
노드는 자바스크립트 런타임입니다.             
따라서 노드는 자바스크립트 프로그램을 컴퓨터에서 실행할 수 있게 해줍니다.       
           
자바스크립트를 브라우저가 아닌 다른 환경에서 사용하고자 했지만 엔진 속도가 문제였다. (느림)               
그러나 2009년 크롬의 **속도가 빠른 ```V8 엔진```이 등장**했으며 이를 기반으로 만들어지기 시작했다.     
      
노드는 ```V8``` 과 더불어 ```libuv``` 라는 라이브러리를 사용한다.       
**libuv 라이브러리**는 노드의 특성인 **이벤트 기반, 논블로킹 I/O 모델을 구현**하고 있다.    
그래서 이들을 이용해 **가볍고 효율적인 장점**을 가지고 있다.      
    
![노드1](https://user-images.githubusercontent.com/50267433/84773180-01d9aa80-b017-11ea-8f7d-d0311880f0fa.jpg)    

## 1.2. 이벤트 기반    
이벤트 기반 시스템에서는 특정 이벤트가 발생할 때 무엇을 할지 미리 등록해두어야 한다.      
이것을 **이벤트 리스너에 콜백 함수를 등록**한다고 표현한다.       
        
```클릭 이벤트 리스너 <- 경고창을 띄우는 콜백 함수 등록```         
이벤트가 발생할 때마다 콜백 함수가 실행돼 경고 창이 뜨게 된다.       
   
노드도 이벤트 기반 방식으로 동작하므로 이벤트가 발생하면 이벤트 리스너에 등록해둔 콜백 함수를 호출한다.     
발생한 이벤트가 없거나 발생했던 이벤트를 다 처리하면 노드는 다음 이벤트가 발생할 때까지 대기한다.      

![노드2](https://user-images.githubusercontent.com/50267433/84774816-50884400-b019-11ea-995a-3030b529cd04.jpg)

## 1.3. 이벤트 루프
이벤트 루프 : 여러 이벤트가 동시에 발생했을 때 어떤 순서로 콜백 함수를 호출할지 판단  
노드는 자바스크립트 코드에서 맨 위부터 한 줄씩 실행합니다.   
함수 호출 부분을 발견했다면 호출한 함수를 호출 스택에 넣습니다.   

### 동기적 이벤트 루프
```javascript
function fisrt(){
   second();
   console.log('첫 번째');
}
function second(){
   third();
   console.log('두 번째');
}
function third(){
   console.log('첫 번째');
}
first();
```   
main 함수는 처음 실행 시의 전역 컨텍스트를 의미한다.        
컨텍스트 : 함수가 호출 되었을 때 생성되는 환경을 의미한다.         
자바 스크립트는 실행 시 기본적으로 전역 컨텍스트 안에서 돌아간다고 생각하는게 좋다.      
      
함수의 실행이 완료되면 호출 스택에서 지워지고 ```third -> second -> first -> main``` 순으로 완료된다.       
   
![노드3](https://user-images.githubusercontent.com/50267433/84776707-9d6d1a00-b01b-11ea-9d66-60089da99f74.jpg)    

**결과**
```
세 번째
두 번째 
첫 번째  
```

### 비동기적 이벤트 루프
```javascript
function run(){
   console.log('3초 후 실행');
}
console.log('시작');
setTimeout(run, 3000);
console.log('끝');
```
**결과**
```
시작
끝 
3초 후 실행  
```
위 코드는 3초 뒤에 run 함수를 실행하는 코드이다.      
콘솔 결과는 쉽게 예측할 수 있지만, 호출 스택으로 설명하기는 힘듭니다.     
**setTimeout 함수의 콜백인 run이 호출 스택에 언제들어가는지 알기 어렵기 때문입니다.**
이를 위해서 루프, 태스크 큐, 백그라운드를 알아야 합니다

* **이벤트 루프 :** 이벤트 발생 시 호출할 콜백 함수들을 관리하고, 호출된 콜백 함수의 실행 순서를 경정하는 역할을 담당합니다.  
노드가 종료될 때까지 이벤트 처리를 위한 작업을 반복하므로 루프라고 불립니다.(호출 스택으로 보내기)     
* **태스크 큐 :** 이벤트 발생 후 호출되어야 할 콜백 함수들이 기다리는 공간입니다.   
콜백들이 이벤트 루프가 정한 순서대로 줄을 서 있으므로 콜백 큐라고 부릅니다.  
* **백그라운드 :** 타이머나 I/O 작업 콜백 또는 이벤트 리스너들이 대기하는 곳입니다.  

![노드4](https://user-images.githubusercontent.com/50267433/84776895-de652e80-b01b-11ea-87bc-673aa7efe8da.jpg)   
![노드5](https://user-images.githubusercontent.com/50267433/84776918-e58c3c80-b01b-11ea-974d-31ab89cc131d.jpg)   
![노드6](https://user-images.githubusercontent.com/50267433/84776946-eb821d80-b01b-11ea-8542-df6994990362.jpg)  
   
1. 일반적인 코드들은 호출 스택에 쌓인다.     
2. setTimout 과 같은 ```타이머```나 ```I/O 작업``` 실행시 해당 콜백은 백그라운드로 이동되어진다.              
3. 백그라운드에서 특정 시간, 조건이 지나면(예를 들면 3초 후) 해당 콜백을 태스크 큐로 보낸다.            
4. 기존 호출 스택 실행이 끝나 비워지면 (꼭 비워진 상태여야만 가능하다. 만약 안비워졌으면 예측 시간보다 더 걸릴 수 있다.)                      
5. 이벤트 루프가 태스크 큐에 저장된 콜백을 호출 스택으로 올린다.                     
6. 태스크 큐에서 올라온 콜백이 호출 스택에서 실행되고 스택은 비어진다.                    
7. 그리고 이벤트 루프는 태스크 큐에 콜백이 들어올 때까지 대기하게 된다.               

```
만약 호출 스택에 함수들이 너무 많이 차 있으면 3초가 지난 후에도 run 함수가 실행되지 않을 수 있다.   
이벤트 루프는 호출 스택이 비어 있을 때만 태스크 큐에 있는 run 함수를 호출 스택으로 가져오기 때문이다.  
이것이 setTimeout의 시간이 정확하지 않을 수도 있는 이유입니다.   
```  

## 1.4. 논블로킹 I/O   
이벤트 루프를 잘 활용하면 오래 걸리는 작업을 효율적으로 처리할 수 있다.  
 
**논블로킹 방식 :** 오래 걸리는 함수를 **백그라운드로 보내서** 다음 코드가 먼저 실행되게 하고,         
그 함수가 다시 **태스크 큐를 거쳐 호출 스택으로 올라오기를 기다리는 방식**을 사용하면 된다.        

![노드7](https://user-images.githubusercontent.com/50267433/84777637-ccd05680-b01c-11ea-9934-07813ab6732d.jpg)
위 그림을 보면 블로킹보다 논블로킹 방식이 같은 작업을 더 짧은 시간 동안 처리할 수 있음을 알 수 있다.  
하지만 싱글 스레드라는 한계 때문에 자바 스크립트의 모든 코드가 이 방식으로 이득을 볼 수 있는 것은 아니다.  
현재 노드 프로세스 외의 다른 컴퓨팅 자원을 사용할 수 있는 I/O 작업이 주로 시간적 이득을 많이 본다.  
   
I/O는 입력/출력을 의미하는 것으로 파일 시스템 접근이나 네트워크 요청 같은 작업이 I/O의 일종이다.  
그리고 앞서 말했듯이 이러한 작업에서 이득을 보기에 논블로킹을 사용한다.    
      
블로킹과 논블로킹 말고도 동기와 비동기라는 개념도 존재하는데 추후에 배울 예정이니        
동기와 블로킹이 유사하고, 비동기와 논블로킹이 유사하다고만 알아두면 된다.       

**블로킹 방식**
```c++
function logRunningTask(){
     // 오래 걸리는 작업 
     console.log('작업 끝');
}
console.log('시작');
logRunningTask();
console.log('다음 작업');
```

**결과**
```
시작
작업 끝
다음 작업
```

**논 블로킹 방식**
```c++
function logRunningTask(){
     // 오래 걸리는 작업 
     console.log('작업 끝');
}
console.log('시작');
setTimeout(logRunningTask,0);
console.log('다음 작업');
```

**결과**
```
시작
다음 작업
작업 끝
```
**setTimeout(콜백, 0)** 은 코드를 논블로킹으로 만들기 위해 사용하는 기법 중 하나이다.        
setTimeout의 콜백 함수는 태스크 큐로 보내지므로 순서대로 실행되지 않고 호출 스택이 빌때까지 기다린다.     
    
**setTimeout(콜백, 0)**
```
밀리초를 0으로 설정했으므로 바로 실해오디는 것이 아닌가 착각할 수 있습니다.  
하지만 브라우저와 노드에서는 기본적으로 지연 시간이 있으므로 바로 실행되지는 않습니다.  
HTML5 브라우저에서는 4ms, 노드에서는 1ms의 지연 시간이 있습니다.  
```
**노드**에서는 ```setTimeout(콜백, 0)``` 대신 **다른 방식을 주로 사용**한다.     


## 1.5. 싱글 스레드 
노드는 싱글 스레드이므로 작업을 혼자서 처리해야한다. (멀티 스레드는 여러 스레드가 일을 나눠 처리한다.)        
자바스크립트와 노드에서 **논블로킹 사용을 해야하는 중요한 이유는 바로 싱글 스레드이기 때문입니다.**            
한 번에 한 가지 일밖에 처리하지 못하므로 어떠한 작업에서 블로킹이 발생하면 다음 일을 처리하지 못하기 때문이다.           

언뜻보면 여러 개의 일을 동시에 처리할 수 있기 때문에 멀티 스레드가 싱글 스레드보다 좋아 보인다.   
하지만 **꼭 그런 것만은 아닙니다.** 아래 예시를 한번 살펴보도록 합시다.   
   
### 1. 싱글 스레드 블로킹 방식
![노드8](https://user-images.githubusercontent.com/50267433/84786871-46217680-b028-11ea-8594-b268ed8ffb38.jpg)     
    
* 한 음식점에 점원이 한명이 있습니다.  
* 손님은 여러명입니다.
* 블로킹 방식으로 처음 손님의 주문을 받고 서빙까지 해주어야 하고 나머지 두명의 손님은 한참 기다랴야 합니다.   
* 이는 엄청 비효율적임을 알 수 있습니다.


### 2. 싱글 스레드 논블로킹 방식    
![노드9](https://user-images.githubusercontent.com/50267433/84786893-4d488480-b028-11ea-88c5-be1944021697.jpg)   
  
* 한 음식점에 점원이 한명이 있습니다.       
* 손님은 여러명입니다.      
* 논블로킹 방식으로 모든 손님의 주문을 먼저 받고 주방에서는 차례대로 요리를 만들고 있습니다.      
* 매우 효율적이다.      
* 그러나 그 점원이 아파서 쓰러지거나 주문/서빙 시간이 오래걸리면 주문이 많이 들어왔을 때 버거울 수 있다.      

### 3. 멀티 스레드 블로킹 방식      
![노드10](https://user-images.githubusercontent.com/50267433/84786931-546f9280-b028-11ea-9fb2-9f6140dede16.jpg)    
     
* 한 음식점에 점원이 여러명이 있습니다.        
* 손님은 여러명입니다.      
* 블로킹 방식이지만 멀티이므로 동시에 손님의 주문을 받고 주방에서는 요리를 만들고 있습니다.        
* 더군다나 점원 한명이 쓰러져도 다른 점원으로 대체하면 되기에 문제가 되지 않는다.    
* 그러나 손님의 수가 늘어나면 점원의 수도 늘어나고    
* 손님 수가 줄어들었을 때 일을 하지 않고 노는 점원이 있다는 것도 문제가 된다.        
* 그리고 점원을 새로 고용하거나 기존 직원을 해고하는 것도 비용이 크게 발생한다.(연산이므로 속도 저하)         

### 4. 멀티 스레드(실은 멀티 프로세스) 논블로킹 방식               
멀티 스레드 블로킹 방식도 좋은 방식이지만 상황에 따라 안좋을 수도 있다.        
그렇다면 점원 여러명이 모두 논블로킹 방식으로 주문을 받으면 더 좋지 않을까 하는 생각이 든다.      
실제로 그렇기에 노드도 싱글 스레드 여러 개를 사용해 멀티 스레딩과 비슷한 기능을 하게 할 수 있다.      
하지만 엄밀히 말하면 멀티 스레딩이라기 보다는 멀티 프로세싱에 가깝다.      
        
![노드11](https://user-images.githubusercontent.com/50267433/84786979-65200880-b028-11ea-800d-f501228b5274.jpg)        
     
**프로세스와 스레드의 차이점**       
* 프로세스는 운영체제에서 할당하는 작업의 단위이다.       
노드나 인터넷 브라우저 같은 프로그램은 개별적인 프로세스이다.     
프로세스 간에는 메모리 등의 자원을 공유하지 않습니다.    
      
* 스레드는 프로세스 내에서 실행되는 흐름의 단위입니다.       
하나의 프로세스는 스레드를 여러개 가질 수 있습니다.    
스레드들은 부모 프로세스의 자원을 공유합니다.     
즉, 같은 메모리에 접근할 수 있습니다.       
         
스레드를 작업을 처리하는 일손으로 표현하기도 하는데, 노드 프로세스는 일손이 하나인 셈이다.      
사실 노드 프로세스도 내부적으로는 스레드를 여러개 가지고 있지만 **직접 제어 가능한 스레드가 1개여서 싱글 스레드라 말한다.**    
       
노드는 스레드를 늘리는 대신,        
프로세스 자체를 복사해 여러 작업을 동시에 처리하는 멀티 프로세싱 방식을 택했다.           
(자바 스크립트 언어 자체가 싱글 스레드 특성을 띠고 있기 때문이다)        
   
***
# 2. 서버로서의 노드  
노드를 서버로 사용할 때의 특징과 장단점에 대해서 알아보자  
   
노드가 싱글 스레드, 논블로킹 모델을 사용하므로 노드 서버 또한  동일한 모델일 수 밖에 없다.      
싱글 스레드여서 멀티 스레드 방식보다는 **컴퓨터 자원을 적게 사용하는 장점**이 있지만,     
**CPU 코어를 하나밖에 사용하지 못한다는 단점도 있다.**     
   
노드는 **I/O가 많은 작업에 적합하다.**    
노드는 libuv 라이브러리를 사용하여 I/O작업을 논블로킹 방식으로 처리해준다.   
따라서 스레드 하나사 많은 수의 I/O를 혼자서도 감당할 수 있다.  
하지만 **CPU 부하가 큰 작업에는 적합하지 않다.**   
     
싱글 스레드 방식의 프로그래밍은 멀티 스레드 방식보다 상대적으로 쉽다.  
하지만 싱글 스레드이다 보니 하나뿐인 스레드가 에러로 인해 멈추지 않도록 잘 관리해야 한다.   
에러를 제대로 처리하지 못하면 서버 전체가 멈추기 때문이다.  
   
또한 노드는 웹 서버가 내장되어 있어 입문자가 쉽게 접근할 수 있다.  
하지만 나중에 서버 규모가 커지면 결국 ngingx 등의 웹 서버를 노드 서버와 연결해야 한다.   
    
노드의 가장 큰 장점으로 언어가 자바스크립트라는 점이다.       
하나의 언어로 웹사이트를 개발할 수 있어 생산성을 획기적으로 높여주기 때문이다.  
또한 JSON을 사용해서 데이터를 주고 받는 것을 쉽게 처리할 수 있다.    
    
노드는 생산성이 매우 좋지만,       
Go 처럼 비동기에 강점을 보이는 언어나            
ngingx 처럼 정적 파일 제공, 로드 밸런싱에 특화된 서버에 비해서는 속도가 느리다.       
그렇긴 해도 극단적인 성능이 필요하지 않다면 이러한 단점은 노드의 생산성으로 어느 정도 극복할 수 있다.    
   
![노드12](https://user-images.githubusercontent.com/50267433/84787120-900a5c80-b028-11ea-8149-f59ec68b4e14.jpg)

**장점**    
1. 멀티 스레드 방식에 비해 컴퓨터 자원을 적게 사용한다.   
2. I/O 작업이 많은 서버로 적합하다.  
3. 멀티 스레드 방식보다 쉽다.  
4. 웹 서버가 내장되어 있다.  
5. 자바 스크립트를 사용한다.  
6. JSON 형식과 호환하기 쉽다.   
        
**단점**
1. 싱글 스레드라서 CPU 코어를 하나만 사용한다.     
2. CPU 작업이 많은 서버로는 부적합하다.      
3. 하나뿐인 스레드가 멈출지 않도록 관리해야 한다.    
4. 서버 규모가 커졌을 때 서버를 관리하기 어렵다.  
5. 어중간한 성능이다.   
   
___
이와 같은 특성을 활용하려면 노드를 어디에 사용하는 것이 좋을까?   
**개수는 많지만 크기는 작은 데이터를 실시간으로 주고 받는 데 적합하다.**  
네트워크나 데이터베이스, 디스크 작업 같은 I/O에 특화되어 있기 때문이다.   
실시간 채팅 애플리케이션이나 주식 차트, JSON 데이터를 제공하는 API 서버가 노드를 많이 사용한다.   
      
노드가 아무리 좋다고 하더라도 추천하지 않는 경우도 있다.    
**이미지나 비디오 처리, 대규모 데이터 처리 같이 CPU를 많이 사용하는 작업을 위한 서버로는 권장하지 않는다.**    
요즘은 AWS Lamda 나 Google Cloud Functions 같은 서비스에서 노드로 CPU를 많이 사용하는 작업을 처리하는 것을 지원한다.    
   
그렇다면 실생활과 밀접한 쇼핑몰, 블로그 같은 웹 사이트에는 적합할까요?        
이런 사이트는 보통 기본적인 틀이 있고, 그 안의 내용물만 달라진다.        
노드가 다른 서버 언어에 비해 이러한 콘텐츠를 제공하는 데 장점이 뚜렷하지는 않다.        
하지만 그렇다고 적하하지 않다는 것도 아니다.     
Pug 나 EJS 같은 템플릿 엔진을 통해서 다른 언어와 비슷하게 콘텐츠를 제공할 수 있다.     
또한 안정성과 보안성 문제도 충분히 검증되었다.        
   
***
# 3. 서버외의 노드   
노드는 자바스크립트 런타입이기 때문에 용도가 서버에만 한정된 것은 아니다.       
사용 범위가 점점 늘어나 웹, 모바일, 데스크톱 애플리케이션 개발에도 사용되기 시작했다.     
       
웹 프레임워크 : Angular, React, Vue, Meteor    
모바일 개발 도구 : React Native, Ionic Framework       
데스크탑 개발 도구 : Electron -> (만듬) -> Atom, Slack, Discord, VSCode 등이 있다.    
    
