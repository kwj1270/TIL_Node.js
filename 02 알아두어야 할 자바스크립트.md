알아두어야 할 자바스크립트
=======================
# 1. ES2015+
2015년에는 자바스크립트 문법에 매우 큰 변화가 있었습니다. **바로 ES2015(ES6) 가 등장한 것입니다.**            
2015년을 기점으로 매년 문법 변경 사항을 발표하고, 새로운 문법 상세에 대해서도 활발한 논의가 이루어지고 있었습니다.           
또한 다른 언어들의 장점을 본딴 편리한 기능이 많이 추가되었기에 이제는 ES2015 이상의 자바스크립트를 배울때 입니다.    

## 1.1. const, let   
보통 자바스크립트를 배울 때 var 변수를 선언하는 방법부터 배웁니다.   
하지만 var는 이제 **const 와 let 이 대체합니다.**    
   
먼저 const 와 let 이 공통으로 가지는 특징인 블록 스코프에 대해 알아봅시다.   
   
**var 와 const/let 예시**      
```javascript 
if(true){
  var x = 3;
}
console.log(x); // 3

if(true){
  const y = 3;
}
console.log(y); // Uncaught ReferenceError: y is not defined
```
x는 정상적으로 출력되는데 y는 에러가 발생합니다.     
     
* **var :** ```함수스코프```를 가지므로 if 문의 블록과 관계없이 접근할 수 있습니다. (현재 위치도 함수 내 이므로)             
* **const, let :** 은 ```블록 스코프```를 가지므로 블록 밖에서는 변수에 접근할 수 없습니다. (중괄호 내)    
그리고 이러한 블록 스코프를 이용함으로써 호스팅 같은 문제도 해결되고 코드 관리도 수월해졌다.   
      
* **const :** 한 번 대입하면 다른 값을 대입할 수 없다.      
다른 대입값을 넣으려고 하면 에러가 발생하고, 변수 초기화시 값을 대입하지 않을 경우 에러가 발생한다.  

* **let :** 블록 스코프 ```변수```이며 다른 값으로 변경해도 된다.      
   
**const 예시**
```javascript
const a = 0;
a = 1; // Uncaught TypeError: Assignment to constant variable     

let b = 0;    
b = 1; // 1   

const c; // Uncaught SyntaxError: Missing initailizer in const declaration    
```     
자바스크립트를 사용할 때 한 번 초기화했던 변수에 다른 값을 대입하는 경우는 의외로 적습니다.      
따라서 기본적으로 변수 선언 시에는 const를 사용하고, 다른 값을 대입해야 하는 상황이 생겼을 때 let을 사용합니다.  

## 1.2. 템플릿 문자열   
ES2015 문법에서는 기존 문자열과 다르게 백틱 ``` ` ```을 사용할 수 있게 되었습니다.    
특이한 점은 문자열 안에 변수를 넣을 수 있다는 것입니다.   
   
**이전 코드**
```javascript
var num1 = 1;
var num2 = 2;
var result = 3;
var string1 = num + ' 더하기 ' + num2 + ' 는 \'' + result + '\'' ;   
console.log(string1);
```
문자열 string1 은 띄어쓰기와 변수, 더하기 기호 때문에 가독성이 좋지 않습니다.   
또한, 작은따옴표를 이스케이프하느라 코드가 지저분합니다.   

**ES2015 이후 백틱 코드**
```javascript
var num1 = 1;
var num2 = 2;
var result = 3;
var string1 = `${num1} 더하기 ${num2}는 '${result}'`;
console.log(string1);
```
```${변수}``` 형식으로 변수를 더하기 기호 없이 문자열에 넣을 수 있습니다.         
기존 따옴표 대신에 백틱을 사용하기 때문에 큰 따옴표나 작은따옴표와 함께 사용할 수도 있습니다.     
   
## 1.3. 객체 리터럴       
객체 리터럴에는 편리한 기능들이 추가되었습니다.   

**이전 코드**
```javascript
// 객체내 리터럴 할당 방법 3가지 
// 1. 기존 함수를 리터럴로 할당하기 
// 2. 익명 함수를 리터럴로 할당하기 
// 3. 프로토타입? 을 이용해서 할당하기  

var sayNode = function(){
    console.log('Node');
};
var es = 'ES';
var oldObject = {
    sayJS:function(){
        console.log('JS');
    },
    sayNode : sayNode,
};

// 객체 바깥에서 해야한다.  
oldObject[es + 6] = 'Fantastic'; // [] 사용할 경우 es변수의 값 ES로 바뀐다.      
// oldObject.ES6 = 'Fantastic'; 
// 동적 변수 할당에 유리하다  
   
oldObject.sayNode();
oldObject.sayJS();
console.log(oldObject.ES6);
```
oldObject 객체에 동적으로 속성을 추가하고 있는 모습을 볼 수 있다.   
     
**ES2015 이후 객체 리터럴 코드**
```javascript
var sayNode = function(){
    console.log('Node');
};
var es = 'ES';
var newObject = {
    sayJS(){
        console.log('JS');
    },
    sayNode,
    [es + 6]: 'Fantastic', // 안에서도 가능해졌다 oldObject[es + 6] = 'Fantastic'; 
};
   
newObject.sayNode();
newObject.sayJS();
console.log(newObject.ES6);
```
1. sayJS 같은 객체의 메서드에 함수를 연결할 때 더는 콜론 ```(:)``` 과 function을 붙이지 않아도 됩니다.     
2. ```sayNode : sayNode,``` 처럼 속성명과 변수명이 겺치는 경우에는 한 번만 쓸 수 있게 되었다 -> ```sayNode,```      
```{name : name, age : age}``` JS에서는 이런 중복이 많이 나오는데 이를 쉽게 해결해준다. -> ```{name, age}```      
3. 객체의 속성명을 동적으로 생성할 수 있다.       
예전 문법에서는 속성명을 만들려면 객체 리터럴 바깥에서 선언해야 했다.     
ES2015 문법에서는 객체 리터럴 안에 선언을 해도 된다.  
    
## 1.4. 화살표 함수   
화살표 함수라는 새로운 함수가 추가되었으며, 기존의 ```function() {}```도 그대로 사용할 수 있습니다.         
       
**화살표 함수**   
```javascript
function add1(x, y) {
    return x + y;
}
// 일반적인 함수

const add2 = (x, y) => {
    return x + y;
};
// 화살표를 사용해서 (매개변수) => {} 사용    
   
const add3 = (x, y) => x+y;
// 1줄만 있으면 {} 생략 가능 
// return 일 경우 return 생략가능  
    
const add4 = (x, y) => (x+y);
// 안정성을 위해 () 묶음 처리 가능  

function not1(x) {
    return !x;
}
// 일반적인 함수 

const not2 = x => !x;
// 매개변수가 1개 일 경우 () 생략가능    
```    
    
```add1 == add2 == add3 == add4``` 같은 동작을 하고             
```not1 == not2```  은 같은 동작을 한다.                
       
화살표 함수에서는 function 선언 대신 => 기호로 함수를 선언합니다.                 
또한, 변수에 대입하면 나중에 재사용 할 수 있다.     
     
기존의 function과 다른 점은 this 바인드 방식이다.        
    
**this 비교**      
```javascript  
var relationship = {
    name : 'zero',
    friends : ['nero', 'hero', 'xero'],
    logFriends : function () {
        var that = this;
        this.friends.forEach(function (friend) {
            console.log(that.name, friend);
        });
    },
};
relationship.logFriends();

const relationship2 = {
    name : 'zero',
    friends : ['nero', 'hero', 'xero'],
    logFriends () {
        this.friends.forEach(friend => {
            console.log(this.name, friend);
        });
    },
};
relationship2.logFriends();
```
relationship 의 logfriends() 안의 forEach 문에서는 function 선언문을 사용했다.   
각자 다른 함수 스코프의 this를 가지므로 that이란느 변수를 사용해서 realtaionship에 간접적으로 접근하고 있다.   

하지만 relationship 의 logfriends() 안의 forEach 문에서는 화살표 함수를 사용했다.       
따라서 바깥 스코프인 logFriends()의 this를 그대로 사용할 수 있다.        
상위 스코프의 this를 그대로 물려받은 것이기 때문이다.         
   
그래서 기본적으로 화살표 함수를 사용하고 this의 용도가 조금 다르면 둘중 하나를 골라서 사용하면 된다.  
     
## 1.5. 비구조화 할당  
이름은 어색하지만 매우 유용한 기능입니다.     
객체와 배열로부터 속성이나 요소를 쉽게 꺼낼 수 있습니다.   

**이전 코드**
```javascript
var candyMachine = {
    status : {
        name : 'node',
        count : 5,
    },
    getCandy : function () {
        this.status.count--;
        return this.status.count;
    },
};
var getCandy = candyMachine.getCandy;
var count = candyMachine.status.count;
```

**이후 코드**
```javascript
var candyMachine = {
    status : {
        name : 'node',
        count : 5,
    },
    getCandy() {
        this.status.count--;
        return this.status.count;
    },
};
const {getCandy, status :{count}} = candyMachine
```
당황스럽겠지만, 위 문법은 유효한 문법입니다.        
getCandy와 count 변수가 초기화된 것입니다.            
candyMachine 객체 안의 속성을 찾아서 변수와 매칭해줍니다.          
즉, 같은 이름에 맞게 대입을 시켜준것이라 보면 된다.          
count 처럼 여러 단계 안의 속성도 찾을 수 있습니다.           
   
배열도 비구조화할 수 있습니다.
   
**배열 비구조화 이전 코드**   
```javascript
var array = ['nodejs', {}, 10, true];
var node = array[0];
var obj = array[1];
var bool = array[3];
```
array 란 배열의 첫 번째, 두번째 요소와 마지막 요소를 변수에 대입하는 코드입니다.   

**배열 비구조화 이후 코드**
```javascript
const array = ['nodejs', {}, 10, true];
const [node, obj, , nool] = array;
```
어색해보이지만, 나름대로 규칙이 있습니다.       
node, obj 와 bool의 위치를 보면 array 배열에서 넣어줄 값의 위치와 같다.       
   
비구조화 할당 문법도 코드 줄 수를 상당히 줄여주므로 유용합니다.        
특히 노드는 모듈을 사용하므로 이러한 방식을 자주 사용합니다.       
       
## 1.6. 프로미스   
자바스크립트와 노드에서는 주로 **비동기 프로그래밍**을 합니다.      
특히 이벤트 주도 방식 때문에 콜백 함수를 자주 사용합니다.     
ES2015부터는 자바스크립트와 노드의 API 들이 콜백 대신 프로미스 기반으로 재구성됩니다.   
그래서 악명 높은 콜백헬을 극복했다는 평가를 받고 있습니다.   

           
 
